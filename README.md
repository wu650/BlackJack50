# blackjack-SP
#### Video Demo: https://youtu.be/iMzjygurgH4
#### Description:
This is a single player blackjack game developed entirely using Java. While there are other, better documented libraries/frameworks out there for game development, my primary motivation with this project was to learn how to code in Java, as my prior experiences were mostly in C with some Python as well. My other main goal was to gain a better understanding of OOP, a goal which this project definitely accomplished. The front end UI is implemented using the Java Swing framework, which allows for the creation of window-based applications, and is built on top of the older AWT framework.
  
  Before writing any code, I took a day to write out and diagram my plans for the project on paper. While the final product is far from my initial model, the value of having some sort of idea to work off of was immense, and gave me a list of things to create and implement.
  
  This project was undertaken in two major sections. I started out by writing the backend. The game was initially implemented as a text-based command line game as I tried to get comfortable with the basics of Java and OOP. After finishing the command line game I had to repurpose/reform some of the backend functionality to better align with my goals for a GUI. This exercise helped me develop a better understanding of how to write a backend that can be used to supply visual input for a variety of different game mediums (in this case text and graphical).
  
  I began by setting up ENUMs to hold the suits and card values. ENUMs are unique in Java, in that they serve to do more than simply hold a set of static data that you want to be able to reference repeatedly. They actually allow you to invoke a constructor for each ENUM value, creating a sort of class for each one, with the option to add additional subfields of your choosing. This was vital in my design, as my CARDVALS enum allowed for the storing of both a point value and a name value within each ENUM (ie KING(title: "King",val: 10). 
  
  Afterwards, I created the objects I needed for the game, starting with the smallest (cards) and working up to the game itself. While creating my classes for cards I did some reading on best practices and was introduced to getters and setters, learning the importance of keeping internal fields private where possible, so as to avoid accidental changes at different points in the program.
  #### Backend Classes:
  - CARDVALS/SUITS: The two enums that are used to create each unique card in a 52 card deck. Each ENUM value is sort of its own class, with subfields laid out by a constructor set up within the ENUM. Functions are specified to retrieve the ENUM subvalues here.
  - Card: Creates each card used in the playing deck. Each card is given a value and a suit from the ENUMs when constructed, as well as an isHidden boolean value which is used to determine whether or not it can be seen by the user (one of the dealer's cards stays hidden in blackjack until their turn). Cards does not include methods other than getters and setters. Added a filename field which stores the card file names upon instantiation in the same format as they are kept in the res folder.
  - Player: Houses all players (including the dealer). Players are given a name as well as a boolean to determine whether or not they are the dealer. This isDealer boolean is vital for some gameplay functionality, as the dealer and player have different mechanics in the game. Players also needed the ability to hold a hand of cards, which is created using an ArrayList of the Card class. Cards can be added to the hand one at a time with the addCard method, which works in tandem with the dealCard method to be described in the CardPool class. Player also has a handValue method, which returns the optimal hand value for a player given the cards in their hand. This method takes into account the fact that Aces can be 11 or 1 and adjusts aces down as needed.
  - CardPool: Implements the deck of cards and the discard pile. populateDecks takes an int and creates that number of 52 card decks within the deck Arraylist of cards. shuffleDeck then mixes these cards into a random order using a sorting algorithm that I came up with. This algorithm goes through each card in the deck and swaps it with a card at a randomly generated position in the arraylist (using the Random class with nextInt). dealCard removes one card from the deck and returns that card, which can then be added to the appropriate pile. Finally, a recently implemented repopulateDeck method allows for the discard pile to be returned to the deck with the addAll method, then shuffled. This is useful when the deck runs out of cards to deal.
  - GamePlay: Initially housed all gameplay mechanics (as seen in the last text-based commit) but now houses all game-oriented backend functionality. Any function that is needed to pass info to the project view is located here. This includes dealing the starting hands to users (with a facedown dealer card), checking if a user or dealer has a natural blackjack (returns a boolean), scoreHand, which uses the handValue method from players to score each hand and return a winner (String). Also creates a tally of wins, losses, and draws, implemented with a HashSet of String, Integer, which is updated to reflect the values of each round.
 #### Understanding the Frontend:
  The frontend includes all the Swing components that are used to generate the game window. I primarily used a null layout for the overarching class, and gridlayouts for inner panels. Before doing anything, I created some sketches of my UI plans and calculated appropriate measurements for each panel and subpanel, assuming my 1024x766 display size. Writing out the coordinates and measurements of my components beforehand saved a lot of time as I didn't need to do much moving of the objects once I created them. The Game class is the heart of the whole game, and serves as the link between the UI class and the backend package's classes. The actionhandler is responsible for calling most of the fnctions following user interaction with the front end (some actions are implemented directly with their associated Swing interfaces via Lambda functions). The res folder holds all of the card images, as well as other images that are loaded into the UI. Finally, the frontend package includes a KeyHandler, which implements the keybinding used the pause the game and a Main function, from which execution actually takes place, simply by instantiating an instance of the Game class.
  #### Frontend Classes:
  - UI: Initializes all of the GUI components using the Java swing framework, within a window object called a JFrame. The JFrame then holds various JPanels, which are lightweight containers that can, themselves, be used to hold other Swing objects. The UI consists of a start screen, which houses buttons to start the setup or quit out of the application (therefore stopping all execution and closing the window. A setupUI, which allows the user to choose their preferred number of decks and number of hands to play from two JRadiobutton groups. These radio buttons each have an actionlistener, invoked with a Lanbda function in their construction, that sets the number of decks and hands respectively to be initialized in the backend GamePlay class. The user is also able to enter a name in a text field.
  The main game screen consists of four main JPanels. One for each player hand and a middle for the deck, discard pile, and uiMessagePrompts. Then there is a controlPanelUI that allows the user to advance the game state and also tracks the score. While the UI does do some initial loading of images, and updating is done in the Game class after it is instantiated. The UI class also sets up the name and icon displayed at the top of the window.
  - Game: Instantiates the gameplay and ui classes and allows for communication between them. Game includes a String - "situation" which is constantly updated to reflect the current game state. "situation" is used in conjunction with an action handler and a switch case to execute the appropriate methods in Game.
  #### Key Game methods:
  - renderSetupUP/renderMainGame: These methods are called and set the associated fields visible in the ui class. Rendering the main game also populates the deck and sets the number of hands to be played based on input passed into the radio buttons in the setup.
  - openNewHand: Calls the backend dealStartingHands method to change user hand values and then updates the ui to display the drawn cards. Also checks if either player opened a natural blackjack. Moves to the user's turn if there is no natural.
  - userHit/userStick: Called by the hit button. Adds a card to the player's hand in the backend and calls updateHandDisplay (discussed later) to update the UI, displaying the new card. Then the handscore is calculated. If the score is less than 21 then the user is presented the option again. Otherwise, if the user busts or has blackjack the situation is adjusted and the turn ends. The turn also ends if the user's hand reaches 5 cards. In playtesting, the 5 card limit was not exceeded once. Userstick simply ends the user's turn and advances to the dealer's draw.
  - dealerLogic/dealerDraw: Originally implemented as a while loop in the text based game. Starts by revealing the dealer's card and updating the situation. The second call will result in the dealer sticking if their score is at least 17 and adding a card to hand otherwise. Each call will check if another card needs to be drawn. If a card is to be drawn, the "continue" control button will call the dealerDraw method which adds a card to the dealer's hand and runs through the same checks for a user draw. If the dealer doesn't exceed the hand limit or bust, the situation passes back to dealer logic where another draw decision is made.
  - endOfHand/turnTransition: scores the hand and updates the tally ui to reflect the result. turnTransition then empties the hands in the backend and runs the updateDiscardPile (described later) to show the most recently discarded card on top. Then the hand ui's are emptied and a new hand begins.
  - updateHandDisplay/updateDiscardPile: These methods take in card data from the backend and use it to update the appropiate fields in the ui with associated card image files.
  - resetDeck: Called within draw-related methods when a draw is attempted with inadequate cards. Uses repopulateDeck from backend and updates deck and discard pile icons.
  - setupNewGame: Called from the pause menu (discussed later). Resets all backend and UI states necessary for a game and returns the user to the setupUI to create a fresh game.
  - resumeGame: Called from the pause menu. Activates buttons that were set inactive by the pause menu. This is achieved through the use of an ArrayList that contains the buttons that were active when the game was paused. This ArrayList of buttons is update during each pause with the updateActiveButtons method.
  - pauseGame: Sets visible the pause UI and makes the text invisible in the JTextfield to avoid interference. Also disables all control buttons.
  
  Also of note - Game presents users with specific prompts depending on the gamestate and situation in the uiMessagePrompt JTextField in the display panel. All methods that involve drawing remove the deck icon if they draw the last card. Most methods will update to a different "situation". Game also has 2 int fields - userCardsDisplayed and dealerCardsDisplayed that work with the updateHandDisplay function to make sure the new card is added to the first open spot. These totals are not updated for hidden cards, ensuring that those cards can still be flipped. The res file in the backend holds images for all 52 cards stored in this format (valuesuits.png). This file format matches the format of the filename field within the Card class, allowing for easy image retrieval when cards are to be loaded. 
  # Actionlistener and KeyBinding:
  The game is driven by an Actionlistener (actionHandler), to which all buttons are tied. The action listener takes the button input and runs a switch case depending on what is passed. The "continue" button has numerous uses, so its switch case makes use of an if else statement that checks the game "situation" at the time that continue is pressed, allowing the proper method to be called. 
  
  Implementing the pause menu was difficult, as I was determined to have it be a keybind instead of a button. First I tried with a KeyListener, but the issue was that the object the key listener was tied to had to be the object in focus for the pause menu to be active. I then learned how to use KeyBindings, and found that you could speciy different scopes of focus under which the botton can be active. The one that stood out was an option to keep the the KeyBinding active as long as an object within the object is in focus. To accomplish this, I created an overarching JPanel (gamePanel) in the ui and put all the individual main game. By putting all the main game objects inside of it and binding it to the p key, a pause option is available no matter the gamestate.

  
  

